#!/bin/bash
#
# /usr/bin/rule-update
#
# Generated by Chef for <%= node[:fqdn] %>
#

#
# Copyright (C) 2008-2016 Doug Burks and Security Onion <doug.burks@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#########################################
# Got r00t?
#########################################
if [[ $(/usr/bin/id -u) -ne 0 ]]; then
    echo "rule-update needs root privileges.  Please try again using sudo."
    exit
fi

# Log file path
LOG="/var/log/nsm/pulledpork.log"

INC="/etc/nsm/administration.conf"
. $INC

. $NSM_LIB_DIR/lib-console-utils
. $NSM_LIB_DIR/lib-nsm-common-utils
. $NSM_LIB_DIR/lib-nsm-sensor-utils


function update(){

#########################################
# Variables
#########################################

# How many days of rule backups do you want to keep?
DAYSTOKEEP_RULE_BACKUPS=30

# What user account should be used to execute pulledpork?
PULLEDPORK_USER=sguil

# What group should be given permissions to the pulledpork output?
PULLEDPORK_GROUP=sguil

# The values above can be overridden in securityonion.conf
source /etc/nsm/securityonion.conf

# Current date
date



# Create snort_dynamicrules and snort_dynamicrules_backup directories if they don't already exist
mkdir -p /usr/local/lib/snort_dynamicrules/
mkdir -p /usr/local/lib/snort_dynamicrules_backup/

# Set permissions to allow PULLEDPORK_USER to write rules
if ls /tmp/emerging.rules.tar.gz >/dev/null 2>&1; then chown $PULLEDPORK_USER:$PULLEDPORK_GROUP /tmp/emerging.rules.tar.gz*; fi
if ls /tmp/snortrules-snapshot-*.tar.gz >/dev/null 2>&1; then chown $PULLEDPORK_USER:$PULLEDPORK_GROUP /tmp/snortrules-snapshot-*.tar.gz*; fi

# Create home dir for $PULLEDPORK_USER and set permissions
mkdir -p /home/$PULLEDPORK_USER
chown -R $PULLEDPORK_USER /home/$PULLEDPORK_USER

#########################################
# Is this box a master or slave?
#########################################

# Slave sensors have securityonion_ssh.conf
SSH_DIR="/root/.ssh"
SSH_CONF="$SSH_DIR/securityonion_ssh.conf"
if [ ! -f $SSH_CONF ]; then
    # This box is a master server.

    # If running from cron, pause for a random number of minutes (between 10 and 50).
    if [ "dumb" == "$TERM" ]; then
        RMIN=$(($(dd if=/dev/urandom count=1 2> /dev/null | cksum | cut -d' ' -f1) % 40));
        let RMIN=RMIN+10
        echo "Sleeping for $RMIN minutes to avoid overwhelming rule sites."
        sleep ${RMIN}m
    fi

    # If running Snort, update local_rules in pulledpork.conf and remove old .so files
    if [ "$ENGINE" = "snort" ]; then
        # Check for local Suricata rules that need to be removed
        if grep "^local_rules=/etc/nsm/rules/local.rules,/etc/nsm/rules/decoder-events.rules,/etc/nsm/rules/stream-events.rules,/etc/nsm/rules/http-events.rules,/etc/nsm/rules/smtp-events.rules$" /etc/nsm/pulledpork/pulledpork.conf >/dev/null 2>&1; then
            # Backup pulledpork.conf
            cp /etc/nsm/pulledpork/pulledpork.conf /etc/nsm/pulledpork/pulledpork.conf.bak.`date +%Y%m%d`
            # Remove local Suricata rules
            sed -i 's|^local_rules=/etc/nsm/rules/local.rules,/etc/nsm/rules/decoder-events.rules,/etc/nsm/rules/stream-events.rules,/etc/nsm/rules/http-events.rules,/etc/nsm/rules/smtp-events.rules$|local_rules=/etc/nsm/rules/local.rules|g' /etc/nsm/pulledpork/pulledpork.conf
        fi

        # Check for .so files in snort_dynamicrules directory and move them to backup directory
        if ls /usr/local/lib/snort_dynamicrules/*.so >/dev/null 2>&1; then
            mv /usr/local/lib/snort_dynamicrules/*.so /usr/local/lib/snort_dynamicrules_backup/
        fi
    fi

    # Default to no PulledPork options
    PP_OPTIONS=""

    # OPTION: -T if the user is running Suricata
    if [ "$ENGINE" = "suricata" ]; then
        PP_OPTIONS="$PP_OPTIONS -T"
        echo "ENGINE=suricata, so we'll execute PulledPork with the -T option to avoid adding soid rules to downloaded.rules."
    fi

    SNORT_VERSION_MAJOR="$(snort --version 2>&1 >/dev/null | egrep -o "Version ([0-9]+\.[0-9]+\.[0-9]+)" | cut -d " " -f 2)"
    SNORT_VERSION_SHORT="$(snort --version 2>&1 >/dev/null | egrep -o "Version (\S+)" | cut -d " " -f 2 | tr -d ".")"

    <% if node[:seconion][:pulledpork_proxy] %>
    #######################
    # HACK, be careful of the snort versions, manually appending a 0 to the snort version due to snort version truncation, I blame Cisco.
    # Cisco added back in the trailing 4th version number.
    #######################

    echo "Getting rule archives via wget."
    <% if node[:seconion][:sensor][:vrt_rules_enabled] %>
    wget -q "https://www.snort.org/reg-rules/snortrules-snapshot-${SNORT_VERSION_SHORT}.tar.gz/<%=node[:seconion][:vrt_oinkcode]%>" -O /tmp/snortrules-snapshot-${SNORT_VERSION_SHORT}.tar.gz
    <% end %>
    <% if node[:seconion][:sensor][:vrt_rules_enabled] %>
    wget -q "https://rules.emergingthreatspro.com/<%=node[:seconion][:etpro_oinkcode]%>/snort-$SNORT_VERSION_MAJOR/etpro.rules.tar.gz" -O /tmp/etpro.rules.tar.gz
    <% end %>
    <% end %>

    
    echo "Running PulledPork."
    <% if node[:seconion][:pulledpork_proxy] %>
    # Don't get rules from Internet, assume wget above took care of it.
    /usr/bin/pulledpork.pl -P $PP_OPTIONS -n -c /etc/nsm/pulledpork/pulledpork.conf |
            grep -v "normalizations disabled because not inline" |grep -v "^$"
    <% else %>
    # Go get rules from Internet.
    /usr/bin/pulledpork.pl -P $PP_OPTIONS -c /etc/nsm/pulledpork/pulledpork.conf |
            grep -v "normalizations disabled because not inline" |grep -v "^$"
    <% end %>
else
    # This box is a sensor.  Go get rules from master.

    KEY="$SSH_DIR/securityonion"
    source $SSH_CONF

    # If running from cron, pause for 60 minutes.
    if [ "dumb" == "$TERM" ]; then
        echo "Sleeping for 60 minutes to allow master time to download new rules."
        sleep 60m
    fi

    # Now process NIDS rules.

    # Pull compressed rules and process slave side using pulledpork.
    # Check pulledpork conf for configured rule_url's and scp's them over.
    echo "Copying compressed rules from $SERVERNAME."

    MASTER_RULES=$(ssh -i "$KEY" $SSH_USERNAME@$SERVERNAME grep '^rule_url' /etc/nsm/pulledpork/pulledpork.conf | awk -F '|' '{print $2}' | sed 's/\./*\./g')
    LOCAL_RULES=$(grep '^rule_url' /etc/nsm/pulledpork/pulledpork.conf | awk -F '|' '{print $2}' | sed 's/\./*\./g')

    set -- $MASTER_RULES
    MASTER_LENGTH=${#@}
    set -- $LOCAL_RULES
    LOCAL_LENGTH=${#@}

    # The master must be a super set of all rules.
    # Check to ensure master rule url count is not smaller than local
    # which implies a rule_url was added to the local sensor and not the master.
    # Also warn if local has fewer rule urls than master in case
    # a url was added upstream and not subsequently downstream.
    if [ "$MASTER_LENGTH" -lt "$LOCAL_LENGTH" ]; then
        echo "Error: Master rule_url count is less than Local rule_url count."
        echo "Master must have all rule_urls enabled in its pulledpork.conf."
    elif [ "$MASTER_LENGTH" -gt "$LOCAL_LENGTH" ]; then
        echo "Warning: Local rule_url count is less than Master rule_url count. "
        echo "Ensure this is intended."
    fi

    for COMPRESSED_RULE in $MASTER_RULES; do
        scp -i "$KEY" $SSH_USERNAME@$SERVERNAME:/tmp/$COMPRESSED_RULE /tmp/
    done

    # Default to no PulledPork options
    PP_OPTIONS=""

    # OPTION: -T if the user is running Suricata
    if [ "$ENGINE" = "suricata" ]; then
        PP_OPTIONS="$PP_OPTIONS -T"
        echo "ENGINE=suricata, so we'll execute PulledPork with the -T option to avoid adding soid rules to downloaded.rules."
    fi

    # sanity check what sensors we are using
    if [ -z "$SENSOR_NAME" ]
    then
        SENSOR_NAME=$(sensortab_names_get_on_auto "1")
    fi

    for SENSOR in $SENSOR_NAME
    do
        #########################################
        # NIDS Variables and Backups
        #########################################

        # NIDS rules
        NIDS="/etc/nsm/rules/$SENSOR"
        NIDS_RULES_DOWNLOADED=$NIDS/downloaded.rules
        NIDS_RULES_LOCAL=$NIDS/local.rules

        # Create backup directory if it doesn't already exist
        NIDS_RULES_BACK=$NIDS/backup
        mkdir -p $NIDS_RULES_BACK

        # Backup downloaded.rules and remove old backups
        echo "Backing up current downloaded.rules file before it gets overwritten."
        cp $NIDS_RULES_DOWNLOADED $NIDS_RULES_BACK/downloaded.rules.`date +%Y%m%d%H%M%S`
        echo "Cleaning up downloaded.rules backup files older than $DAYSTOKEEP_RULE_BACKUPS days."
        find $NIDS_RULES_BACK/downloaded.rules.* -type f -mtime +$DAYSTOKEEP_RULE_BACKUPS -exec /bin/rm -f '{}' +

        # Backup local.rules and remove old backups
        echo "Backing up current local.rules file before it gets overwritten."
        cp $NIDS_RULES_LOCAL $NIDS_RULES_BACK/local.rules.`date +%Y%m%d%H%M%S`
        echo "Cleaning up local.rules backup files older than $DAYSTOKEEP_RULE_BACKUPS days."
        find $NIDS_RULES_BACK/local.rules.* -type f -mtime +$DAYSTOKEEP_RULE_BACKUPS -exec /bin/rm -f '{}' +   


        # Process rules local to sensor without starting a separate download.
        echo "Running PulledPork."
        su - $PULLEDPORK_USER -c "/usr/bin/pulledpork.pl -P -n $PP_OPTIONS -c /etc/nsm/pulledpork/$SENSOR/pulledpork.conf" |
                grep -v "normalizations disabled because not inline" |grep -v "^$"
    done
fi

#########################################
# Restart NIDS processes
#########################################

echo "Rule-Update no longer restarts at the end."
echo "Run the following:"
echo "sudo /usr/sbin/nsm_sensor_ps-restart --only-barnyard2; sudo /usr/sbin/nsm_sensor_ps-restart --only-snort-alert"

## If Barnyard is enabled, restart it
#if grep -i 'BARNYARD2_ENABLED="yes"' /etc/nsm/*/sensor.conf >/dev/null 2>&1; then
#    if pgrep barnyard2 >/dev/null 2>&1; then
#        echo "Restarting Barnyard2."
#        /usr/sbin/nsm_sensor_ps-restart --only-barnyard2
#    fi
#fi
#
## If the IDS Engine is enabled, restart it
#if grep -i 'IDS_ENGINE_ENABLED="yes"' /etc/nsm/*/sensor.conf >/dev/null 2>&1; then
#    # We're about to use pgrep to search for the $ENGINE process (snort or suricata).
#    # "pgrep suricata" won't work since the process shows up as Suricata,
#    # so do "pgrep Suricata" instead.
#    [ "$ENGINE" == "suricata" ] && ENGINE="Suricata"
#    if pgrep $ENGINE >/dev/null 2>&1; then
#        echo "Restarting IDS Engine."
#        /usr/sbin/nsm_sensor_ps-restart --only-snort-alert
#    fi
#fi
}
update 2>&1 | tee -a $LOG
